#!/usr/bin/env python3

import os
import sys
import textwrap
import argparse
import shutil
import re


def verbose(msg):
    print(':: ' + msg, file=sys.stderr,flush=True)

def fail(msg):
    print('ERROR: ' + msg, file=sys.stderr,flush=True)
    sys.exit(1)


def strip_prefix(prefix, s):
    if s.startswith(prefix):
        return s[len(prefix):]
    return s


def strip_suffix(suffix, s):
    if s.endswith(suffix):
        return s[0:-len(suffix)]
    return s


def html_fold_proofs(html_src):
    begin_expression = r'<span class="id"[^>]*>(Proof)</span>'
    end_expression = r'<span class="id"[^>]*>(Admitted|Qed|Defined)</span>'
    end_expression += r'[\.]+'
    either_expression = r'('
    either_expression += begin_expression
    either_expression += r'|'
    either_expression += end_expression
    either_expression += r')'
    either_expression = re.compile(either_expression)
    all_chunks = either_expression.split(html_src)
    # group all the contents of the capture groups together:
    grouped_chunks = [all_chunks[0]]
    for i in range(1, len(all_chunks), either_expression.groups + 1):
        match_tuple = tuple(all_chunks[i : i + either_expression.groups])
        grouped_chunks.append(match_tuple)
        grouped_chunks.append(all_chunks[i + either_expression.groups])
    # Debug:
    output = grouped_chunks[0]
    grouped_chunks.pop(0)
    while grouped_chunks:
        # read the start of the potential proof:
        begin_chunk = grouped_chunks.pop(0)
        begin_word = begin_chunk[1]  # capture group 1 in above regexp
        if not grouped_chunks:
            output += begin_chunk[0]
            break
        proof = grouped_chunks.pop(0)

        # we need some lookahead to see whether the
        # next chunk closes the proof:
        end_chunk = None
        end_word = None
        if len(grouped_chunks) > 0:
            end_chunk = grouped_chunks[0]
            end_word = end_chunk[2]  # capture group 2 in above regexp
        # print(f'begin={begin_word} end={end_word}')
        if not begin_word or not end_word:
            # if we don't have a foldable proof, then chust skip this:
            output += begin_chunk[0]
            output += proof
            continue

        # otherwise, the lookahead was successful and we consume end_chunk:
        grouped_chunks.pop(0)
        # print the folded proof:
        output += textwrap.dedent(f"""\
        <details>
         <summary>Expand {begin_word} ... {end_word}</summary>

         <div class="details-content">
         {begin_chunk[0]}{proof}{end_chunk[0]}
         </div>
        </details>
        """)

        # also, pass the text after the QED to the output:
        if not grouped_chunks:
            break
        output += grouped_chunks.pop(0)

    return output


def convert_html_file(full_src_path, full_target_path, args):
    os.makedirs(os.path.dirname(full_target_path), exist_ok=True)
    # try to extract a reasonable title
    filename = os.path.basename(full_src_path)
    title = strip_prefix('Top.', strip_suffix('.html', filename))
    with open(full_src_path) as fh:
        src = fh.read()

    additional_css = []
    for i in args.add_css:
        css_basename = os.path.basename(i)
        line = f'<link href="{css_basename}" rel="stylesheet" type="text/css" />'
        additional_css.append(line)
    additional_css = '\n'.join(additional_css)

    # fold proofs
    src = html_fold_proofs(src)

    # add header and footer
    html_header = f"""\
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml">
     <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
      {additional_css}
      <style>
      </style>
      <title>{title}{args.title_suffix}</title>
     </head>
     <body>
      <div id="page">
       <div id="header">
        <h1>Action Codes Coq Formalization</h1>
        <a href="toc.html">Table of contents</a>
        | <a href="https://arxiv.org/abs/2301.00199">Paper on Arxiv</a>
       </div>
       <div id="main">
    """
    html_footer = f"""\
       </div><!-- id="main" -->
      </div><!-- id="page" -->
     </body>
    </html>
    """
    src = textwrap.dedent(html_header) + src + textwrap.dedent(html_footer)
    # add header / footer
    with open(full_target_path, 'w') as fh:
        fh.write(src)


def main():
    """
    Given the html bodies generated by coqdoc --body-only,
    generate the full html pages for public use.
    """
    description = "Generate full html pages from coqdoc --body-only html."
    parser = argparse.ArgumentParser(description=description,
                                     epilog=textwrap.dedent(main.__doc__))
    parser.add_argument('html-src-dir',
                        help='The directory where coqdoc installed the html files')
    parser.add_argument('target-dir',
                        help='The directory where the full html files will be written to')
    parser.add_argument('--add-css', type=str, nargs='*', default=[],
                        help='link the given css file')
    parser.add_argument('--title-suffix', type=str,
                        help='string appended to the <title> of each file')
    args = parser.parse_args()
    src_dir = vars(args)['html-src-dir']
    target_dir = vars(args)['target-dir']

    # relative paths to files in the source dir
    srcfiles = []
    for dirpath, dirs, files in os.walk(src_dir):
        for f in files:
            srcfiles.append(os.path.relpath(os.path.join(dirpath, f), src_dir))

    for f in srcfiles:
        full_src_path = os.path.join(src_dir, f)
        full_target_path = os.path.join(target_dir, f)
        if full_src_path.endswith('.html'):
            verbose(f'Convert {full_src_path} -> {full_target_path}')
            convert_html_file(full_src_path, full_target_path, args)
        else:
            verbose(f'Copy {full_src_path} -> {full_target_path}')
            shutil.copyfile(full_src_path, full_target_path)
    # add css to target dir
    for i in args.add_css:
        target = os.path.join(target_dir, os.path.basename(i))
        verbose(f'Copy {i} -> {target}')
        shutil.copyfile(i, target)


if __name__ == "__main__":
    main()
